// Generated by Molecule 0.6.1

use molecule :: prelude :: * ;
use super :: basic :: * ;
# [ derive ( Clone ) ] pub struct InfoCellData ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for InfoCellData { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for InfoCellData { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for InfoCellData { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "sudt_x_reserve" , self . sudt_x_reserve ( ) ) ? ; write ! ( f , ", {}: {}" , "sudt_y_reserve" , self . sudt_y_reserve ( ) ) ? ; write ! ( f , ", {}: {}" , "total_liquidity" , self . total_liquidity ( ) ) ? ; write ! ( f , ", {}: {}" , "liquidity_sudt_type_hash" , self . liquidity_sudt_type_hash ( ) ) ? ; write ! ( f , " }}" ) } } impl :: core :: default :: Default for InfoCellData { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ] ; InfoCellData :: new_unchecked ( v . into ( ) ) } } impl InfoCellData { pub const TOTAL_SIZE : usize = 80 ; pub const FIELD_SIZES : [ usize ; 4 ] = [ 16 , 16 , 16 , 32 , ] ; pub const FIELD_COUNT : usize = 4 ; pub fn sudt_x_reserve ( & self ) -> Uint128 { Uint128 :: new_unchecked ( self . 0 . slice ( 0 .. 16 ) ) } pub fn sudt_y_reserve ( & self ) -> Uint128 { Uint128 :: new_unchecked ( self . 0 . slice ( 16 .. 32 ) ) } pub fn total_liquidity ( & self ) -> Uint128 { Uint128 :: new_unchecked ( self . 0 . slice ( 32 .. 48 ) ) } pub fn liquidity_sudt_type_hash ( & self ) -> Byte32 { Byte32 :: new_unchecked ( self . 0 . slice ( 48 .. 80 ) ) } pub fn as_reader < 'r > ( & 'r self ) -> InfoCellDataReader < 'r > { InfoCellDataReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for InfoCellData { type Builder = InfoCellDataBuilder ; const NAME : & 'static str = "InfoCellData" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { InfoCellData ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { InfoCellDataReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { InfoCellDataReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . sudt_x_reserve ( self . sudt_x_reserve ( ) ) . sudt_y_reserve ( self . sudt_y_reserve ( ) ) . total_liquidity ( self . total_liquidity ( ) ) . liquidity_sudt_type_hash ( self . liquidity_sudt_type_hash ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct InfoCellDataReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for InfoCellDataReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for InfoCellDataReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for InfoCellDataReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "sudt_x_reserve" , self . sudt_x_reserve ( ) ) ? ; write ! ( f , ", {}: {}" , "sudt_y_reserve" , self . sudt_y_reserve ( ) ) ? ; write ! ( f , ", {}: {}" , "total_liquidity" , self . total_liquidity ( ) ) ? ; write ! ( f , ", {}: {}" , "liquidity_sudt_type_hash" , self . liquidity_sudt_type_hash ( ) ) ? ; write ! ( f , " }}" ) } } impl < 'r > InfoCellDataReader < 'r > { pub const TOTAL_SIZE : usize = 80 ; pub const FIELD_SIZES : [ usize ; 4 ] = [ 16 , 16 , 16 , 32 , ] ; pub const FIELD_COUNT : usize = 4 ; pub fn sudt_x_reserve ( & self ) -> Uint128Reader < 'r > { Uint128Reader :: new_unchecked ( & self . as_slice ( ) [ 0 .. 16 ] ) } pub fn sudt_y_reserve ( & self ) -> Uint128Reader < 'r > { Uint128Reader :: new_unchecked ( & self . as_slice ( ) [ 16 .. 32 ] ) } pub fn total_liquidity ( & self ) -> Uint128Reader < 'r > { Uint128Reader :: new_unchecked ( & self . as_slice ( ) [ 32 .. 48 ] ) } pub fn liquidity_sudt_type_hash ( & self ) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked ( & self . as_slice ( ) [ 48 .. 80 ] ) } } impl < 'r > molecule :: prelude :: Reader < 'r > for InfoCellDataReader < 'r > { type Entity = InfoCellData ; const NAME : & 'static str = "InfoCellDataReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { InfoCellDataReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , _compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len != Self :: TOTAL_SIZE { return ve ! ( Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len ) ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct InfoCellDataBuilder { pub ( crate ) sudt_x_reserve : Uint128 , pub ( crate ) sudt_y_reserve : Uint128 , pub ( crate ) total_liquidity : Uint128 , pub ( crate ) liquidity_sudt_type_hash : Byte32 , } impl InfoCellDataBuilder { pub const TOTAL_SIZE : usize = 80 ; pub const FIELD_SIZES : [ usize ; 4 ] = [ 16 , 16 , 16 , 32 , ] ; pub const FIELD_COUNT : usize = 4 ; pub fn sudt_x_reserve ( mut self , v : Uint128 ) -> Self { self . sudt_x_reserve = v ; self } pub fn sudt_y_reserve ( mut self , v : Uint128 ) -> Self { self . sudt_y_reserve = v ; self } pub fn total_liquidity ( mut self , v : Uint128 ) -> Self { self . total_liquidity = v ; self } pub fn liquidity_sudt_type_hash ( mut self , v : Byte32 ) -> Self { self . liquidity_sudt_type_hash = v ; self } } impl molecule :: prelude :: Builder for InfoCellDataBuilder { type Entity = InfoCellData ; const NAME : & 'static str = "InfoCellDataBuilder" ; fn expected_length ( & self ) -> usize { Self :: TOTAL_SIZE } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { writer . write_all ( self . sudt_x_reserve . as_slice ( ) ) ? ; writer . write_all ( self . sudt_y_reserve . as_slice ( ) ) ? ; writer . write_all ( self . total_liquidity . as_slice ( ) ) ? ; writer . write_all ( self . liquidity_sudt_type_hash . as_slice ( ) ) ? ; Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; InfoCellData :: new_unchecked ( inner . into ( ) ) } }
# [ derive ( Clone ) ] pub struct LiquidityRequestLockArgs ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for LiquidityRequestLockArgs { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for LiquidityRequestLockArgs { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for LiquidityRequestLockArgs { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "info_type_hash" , self . info_type_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "user_lock_hash" , self . user_lock_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "version" , self . version ( ) ) ? ; write ! ( f , ", {}: {}" , "sudt_x_min" , self . sudt_x_min ( ) ) ? ; write ! ( f , ", {}: {}" , "sudt_y_min" , self . sudt_y_min ( ) ) ? ; write ! ( f , ", {}: {}" , "tips_ckb" , self . tips_ckb ( ) ) ? ; write ! ( f , ", {}: {}" , "tips_sudt_x" , self . tips_sudt_x ( ) ) ? ; write ! ( f , ", {}: {}" , "tips_sudt_y" , self . tips_sudt_y ( ) ) ? ; write ! ( f , " }}" ) } } impl :: core :: default :: Default for LiquidityRequestLockArgs { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ] ; LiquidityRequestLockArgs :: new_unchecked ( v . into ( ) ) } } impl LiquidityRequestLockArgs { pub const TOTAL_SIZE : usize = 137 ; pub const FIELD_SIZES : [ usize ; 8 ] = [ 32 , 32 , 1 , 16 , 16 , 8 , 16 , 16 , ] ; pub const FIELD_COUNT : usize = 8 ; pub fn info_type_hash ( & self ) -> Byte32 { Byte32 :: new_unchecked ( self . 0 . slice ( 0 .. 32 ) ) } pub fn user_lock_hash ( & self ) -> Byte32 { Byte32 :: new_unchecked ( self . 0 . slice ( 32 .. 64 ) ) } pub fn version ( & self ) -> Uint8 { Uint8 :: new_unchecked ( self . 0 . slice ( 64 .. 65 ) ) } pub fn sudt_x_min ( & self ) -> Uint128 { Uint128 :: new_unchecked ( self . 0 . slice ( 65 .. 81 ) ) } pub fn sudt_y_min ( & self ) -> Uint128 { Uint128 :: new_unchecked ( self . 0 . slice ( 81 .. 97 ) ) } pub fn tips_ckb ( & self ) -> Uint64 { Uint64 :: new_unchecked ( self . 0 . slice ( 97 .. 105 ) ) } pub fn tips_sudt_x ( & self ) -> Uint128 { Uint128 :: new_unchecked ( self . 0 . slice ( 105 .. 121 ) ) } pub fn tips_sudt_y ( & self ) -> Uint128 { Uint128 :: new_unchecked ( self . 0 . slice ( 121 .. 137 ) ) } pub fn as_reader < 'r > ( & 'r self ) -> LiquidityRequestLockArgsReader < 'r > { LiquidityRequestLockArgsReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for LiquidityRequestLockArgs { type Builder = LiquidityRequestLockArgsBuilder ; const NAME : & 'static str = "LiquidityRequestLockArgs" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { LiquidityRequestLockArgs ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { LiquidityRequestLockArgsReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { LiquidityRequestLockArgsReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . info_type_hash ( self . info_type_hash ( ) ) . user_lock_hash ( self . user_lock_hash ( ) ) . version ( self . version ( ) ) . sudt_x_min ( self . sudt_x_min ( ) ) . sudt_y_min ( self . sudt_y_min ( ) ) . tips_ckb ( self . tips_ckb ( ) ) . tips_sudt_x ( self . tips_sudt_x ( ) ) . tips_sudt_y ( self . tips_sudt_y ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct LiquidityRequestLockArgsReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for LiquidityRequestLockArgsReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for LiquidityRequestLockArgsReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for LiquidityRequestLockArgsReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "info_type_hash" , self . info_type_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "user_lock_hash" , self . user_lock_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "version" , self . version ( ) ) ? ; write ! ( f , ", {}: {}" , "sudt_x_min" , self . sudt_x_min ( ) ) ? ; write ! ( f , ", {}: {}" , "sudt_y_min" , self . sudt_y_min ( ) ) ? ; write ! ( f , ", {}: {}" , "tips_ckb" , self . tips_ckb ( ) ) ? ; write ! ( f , ", {}: {}" , "tips_sudt_x" , self . tips_sudt_x ( ) ) ? ; write ! ( f , ", {}: {}" , "tips_sudt_y" , self . tips_sudt_y ( ) ) ? ; write ! ( f , " }}" ) } } impl < 'r > LiquidityRequestLockArgsReader < 'r > { pub const TOTAL_SIZE : usize = 137 ; pub const FIELD_SIZES : [ usize ; 8 ] = [ 32 , 32 , 1 , 16 , 16 , 8 , 16 , 16 , ] ; pub const FIELD_COUNT : usize = 8 ; pub fn info_type_hash ( & self ) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked ( & self . as_slice ( ) [ 0 .. 32 ] ) } pub fn user_lock_hash ( & self ) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked ( & self . as_slice ( ) [ 32 .. 64 ] ) } pub fn version ( & self ) -> Uint8Reader < 'r > { Uint8Reader :: new_unchecked ( & self . as_slice ( ) [ 64 .. 65 ] ) } pub fn sudt_x_min ( & self ) -> Uint128Reader < 'r > { Uint128Reader :: new_unchecked ( & self . as_slice ( ) [ 65 .. 81 ] ) } pub fn sudt_y_min ( & self ) -> Uint128Reader < 'r > { Uint128Reader :: new_unchecked ( & self . as_slice ( ) [ 81 .. 97 ] ) } pub fn tips_ckb ( & self ) -> Uint64Reader < 'r > { Uint64Reader :: new_unchecked ( & self . as_slice ( ) [ 97 .. 105 ] ) } pub fn tips_sudt_x ( & self ) -> Uint128Reader < 'r > { Uint128Reader :: new_unchecked ( & self . as_slice ( ) [ 105 .. 121 ] ) } pub fn tips_sudt_y ( & self ) -> Uint128Reader < 'r > { Uint128Reader :: new_unchecked ( & self . as_slice ( ) [ 121 .. 137 ] ) } } impl < 'r > molecule :: prelude :: Reader < 'r > for LiquidityRequestLockArgsReader < 'r > { type Entity = LiquidityRequestLockArgs ; const NAME : & 'static str = "LiquidityRequestLockArgsReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { LiquidityRequestLockArgsReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , _compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len != Self :: TOTAL_SIZE { return ve ! ( Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len ) ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct LiquidityRequestLockArgsBuilder { pub ( crate ) info_type_hash : Byte32 , pub ( crate ) user_lock_hash : Byte32 , pub ( crate ) version : Uint8 , pub ( crate ) sudt_x_min : Uint128 , pub ( crate ) sudt_y_min : Uint128 , pub ( crate ) tips_ckb : Uint64 , pub ( crate ) tips_sudt_x : Uint128 , pub ( crate ) tips_sudt_y : Uint128 , } impl LiquidityRequestLockArgsBuilder { pub const TOTAL_SIZE : usize = 137 ; pub const FIELD_SIZES : [ usize ; 8 ] = [ 32 , 32 , 1 , 16 , 16 , 8 , 16 , 16 , ] ; pub const FIELD_COUNT : usize = 8 ; pub fn info_type_hash ( mut self , v : Byte32 ) -> Self { self . info_type_hash = v ; self } pub fn user_lock_hash ( mut self , v : Byte32 ) -> Self { self . user_lock_hash = v ; self } pub fn version ( mut self , v : Uint8 ) -> Self { self . version = v ; self } pub fn sudt_x_min ( mut self , v : Uint128 ) -> Self { self . sudt_x_min = v ; self } pub fn sudt_y_min ( mut self , v : Uint128 ) -> Self { self . sudt_y_min = v ; self } pub fn tips_ckb ( mut self , v : Uint64 ) -> Self { self . tips_ckb = v ; self } pub fn tips_sudt_x ( mut self , v : Uint128 ) -> Self { self . tips_sudt_x = v ; self } pub fn tips_sudt_y ( mut self , v : Uint128 ) -> Self { self . tips_sudt_y = v ; self } } impl molecule :: prelude :: Builder for LiquidityRequestLockArgsBuilder { type Entity = LiquidityRequestLockArgs ; const NAME : & 'static str = "LiquidityRequestLockArgsBuilder" ; fn expected_length ( & self ) -> usize { Self :: TOTAL_SIZE } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { writer . write_all ( self . info_type_hash . as_slice ( ) ) ? ; writer . write_all ( self . user_lock_hash . as_slice ( ) ) ? ; writer . write_all ( self . version . as_slice ( ) ) ? ; writer . write_all ( self . sudt_x_min . as_slice ( ) ) ? ; writer . write_all ( self . sudt_y_min . as_slice ( ) ) ? ; writer . write_all ( self . tips_ckb . as_slice ( ) ) ? ; writer . write_all ( self . tips_sudt_x . as_slice ( ) ) ? ; writer . write_all ( self . tips_sudt_y . as_slice ( ) ) ? ; Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; LiquidityRequestLockArgs :: new_unchecked ( inner . into ( ) ) } }
# [ derive ( Clone ) ] pub struct MintLiquidityRequestLockArgs ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for MintLiquidityRequestLockArgs { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for MintLiquidityRequestLockArgs { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for MintLiquidityRequestLockArgs { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "info_type_hash" , self . info_type_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "user_lock_hash" , self . user_lock_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "version" , self . version ( ) ) ? ; write ! ( f , ", {}: {}" , "req_sudt_x_cell_lock_hash" , self . req_sudt_x_cell_lock_hash ( ) ) ? ; write ! ( f , " }}" ) } } impl :: core :: default :: Default for MintLiquidityRequestLockArgs { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ] ; MintLiquidityRequestLockArgs :: new_unchecked ( v . into ( ) ) } } impl MintLiquidityRequestLockArgs { pub const TOTAL_SIZE : usize = 97 ; pub const FIELD_SIZES : [ usize ; 4 ] = [ 32 , 32 , 1 , 32 , ] ; pub const FIELD_COUNT : usize = 4 ; pub fn info_type_hash ( & self ) -> Byte32 { Byte32 :: new_unchecked ( self . 0 . slice ( 0 .. 32 ) ) } pub fn user_lock_hash ( & self ) -> Byte32 { Byte32 :: new_unchecked ( self . 0 . slice ( 32 .. 64 ) ) } pub fn version ( & self ) -> Uint8 { Uint8 :: new_unchecked ( self . 0 . slice ( 64 .. 65 ) ) } pub fn req_sudt_x_cell_lock_hash ( & self ) -> Byte32 { Byte32 :: new_unchecked ( self . 0 . slice ( 65 .. 97 ) ) } pub fn as_reader < 'r > ( & 'r self ) -> MintLiquidityRequestLockArgsReader < 'r > { MintLiquidityRequestLockArgsReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for MintLiquidityRequestLockArgs { type Builder = MintLiquidityRequestLockArgsBuilder ; const NAME : & 'static str = "MintLiquidityRequestLockArgs" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { MintLiquidityRequestLockArgs ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { MintLiquidityRequestLockArgsReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { MintLiquidityRequestLockArgsReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . info_type_hash ( self . info_type_hash ( ) ) . user_lock_hash ( self . user_lock_hash ( ) ) . version ( self . version ( ) ) . req_sudt_x_cell_lock_hash ( self . req_sudt_x_cell_lock_hash ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct MintLiquidityRequestLockArgsReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for MintLiquidityRequestLockArgsReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for MintLiquidityRequestLockArgsReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for MintLiquidityRequestLockArgsReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "info_type_hash" , self . info_type_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "user_lock_hash" , self . user_lock_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "version" , self . version ( ) ) ? ; write ! ( f , ", {}: {}" , "req_sudt_x_cell_lock_hash" , self . req_sudt_x_cell_lock_hash ( ) ) ? ; write ! ( f , " }}" ) } } impl < 'r > MintLiquidityRequestLockArgsReader < 'r > { pub const TOTAL_SIZE : usize = 97 ; pub const FIELD_SIZES : [ usize ; 4 ] = [ 32 , 32 , 1 , 32 , ] ; pub const FIELD_COUNT : usize = 4 ; pub fn info_type_hash ( & self ) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked ( & self . as_slice ( ) [ 0 .. 32 ] ) } pub fn user_lock_hash ( & self ) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked ( & self . as_slice ( ) [ 32 .. 64 ] ) } pub fn version ( & self ) -> Uint8Reader < 'r > { Uint8Reader :: new_unchecked ( & self . as_slice ( ) [ 64 .. 65 ] ) } pub fn req_sudt_x_cell_lock_hash ( & self ) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked ( & self . as_slice ( ) [ 65 .. 97 ] ) } } impl < 'r > molecule :: prelude :: Reader < 'r > for MintLiquidityRequestLockArgsReader < 'r > { type Entity = MintLiquidityRequestLockArgs ; const NAME : & 'static str = "MintLiquidityRequestLockArgsReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { MintLiquidityRequestLockArgsReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , _compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len != Self :: TOTAL_SIZE { return ve ! ( Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len ) ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct MintLiquidityRequestLockArgsBuilder { pub ( crate ) info_type_hash : Byte32 , pub ( crate ) user_lock_hash : Byte32 , pub ( crate ) version : Uint8 , pub ( crate ) req_sudt_x_cell_lock_hash : Byte32 , } impl MintLiquidityRequestLockArgsBuilder { pub const TOTAL_SIZE : usize = 97 ; pub const FIELD_SIZES : [ usize ; 4 ] = [ 32 , 32 , 1 , 32 , ] ; pub const FIELD_COUNT : usize = 4 ; pub fn info_type_hash ( mut self , v : Byte32 ) -> Self { self . info_type_hash = v ; self } pub fn user_lock_hash ( mut self , v : Byte32 ) -> Self { self . user_lock_hash = v ; self } pub fn version ( mut self , v : Uint8 ) -> Self { self . version = v ; self } pub fn req_sudt_x_cell_lock_hash ( mut self , v : Byte32 ) -> Self { self . req_sudt_x_cell_lock_hash = v ; self } } impl molecule :: prelude :: Builder for MintLiquidityRequestLockArgsBuilder { type Entity = MintLiquidityRequestLockArgs ; const NAME : & 'static str = "MintLiquidityRequestLockArgsBuilder" ; fn expected_length ( & self ) -> usize { Self :: TOTAL_SIZE } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { writer . write_all ( self . info_type_hash . as_slice ( ) ) ? ; writer . write_all ( self . user_lock_hash . as_slice ( ) ) ? ; writer . write_all ( self . version . as_slice ( ) ) ? ; writer . write_all ( self . req_sudt_x_cell_lock_hash . as_slice ( ) ) ? ; Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; MintLiquidityRequestLockArgs :: new_unchecked ( inner . into ( ) ) } }
# [ derive ( Clone ) ] pub struct SwapRequestLockArgs ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for SwapRequestLockArgs { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for SwapRequestLockArgs { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for SwapRequestLockArgs { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "sudt_type_hash" , self . sudt_type_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "user_lock_hash" , self . user_lock_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "version" , self . version ( ) ) ? ; write ! ( f , ", {}: {}" , "min_amount_out" , self . min_amount_out ( ) ) ? ; write ! ( f , ", {}: {}" , "tips_ckb" , self . tips_ckb ( ) ) ? ; write ! ( f , ", {}: {}" , "tips_sudt" , self . tips_sudt ( ) ) ? ; write ! ( f , " }}" ) } } impl :: core :: default :: Default for SwapRequestLockArgs { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ] ; SwapRequestLockArgs :: new_unchecked ( v . into ( ) ) } } impl SwapRequestLockArgs { pub const TOTAL_SIZE : usize = 105 ; pub const FIELD_SIZES : [ usize ; 6 ] = [ 32 , 32 , 1 , 16 , 8 , 16 , ] ; pub const FIELD_COUNT : usize = 6 ; pub fn sudt_type_hash ( & self ) -> Byte32 { Byte32 :: new_unchecked ( self . 0 . slice ( 0 .. 32 ) ) } pub fn user_lock_hash ( & self ) -> Byte32 { Byte32 :: new_unchecked ( self . 0 . slice ( 32 .. 64 ) ) } pub fn version ( & self ) -> Uint8 { Uint8 :: new_unchecked ( self . 0 . slice ( 64 .. 65 ) ) } pub fn min_amount_out ( & self ) -> Uint128 { Uint128 :: new_unchecked ( self . 0 . slice ( 65 .. 81 ) ) } pub fn tips_ckb ( & self ) -> Uint64 { Uint64 :: new_unchecked ( self . 0 . slice ( 81 .. 89 ) ) } pub fn tips_sudt ( & self ) -> Uint128 { Uint128 :: new_unchecked ( self . 0 . slice ( 89 .. 105 ) ) } pub fn as_reader < 'r > ( & 'r self ) -> SwapRequestLockArgsReader < 'r > { SwapRequestLockArgsReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for SwapRequestLockArgs { type Builder = SwapRequestLockArgsBuilder ; const NAME : & 'static str = "SwapRequestLockArgs" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { SwapRequestLockArgs ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SwapRequestLockArgsReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SwapRequestLockArgsReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . sudt_type_hash ( self . sudt_type_hash ( ) ) . user_lock_hash ( self . user_lock_hash ( ) ) . version ( self . version ( ) ) . min_amount_out ( self . min_amount_out ( ) ) . tips_ckb ( self . tips_ckb ( ) ) . tips_sudt ( self . tips_sudt ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct SwapRequestLockArgsReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for SwapRequestLockArgsReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for SwapRequestLockArgsReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for SwapRequestLockArgsReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "sudt_type_hash" , self . sudt_type_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "user_lock_hash" , self . user_lock_hash ( ) ) ? ; write ! ( f , ", {}: {}" , "version" , self . version ( ) ) ? ; write ! ( f , ", {}: {}" , "min_amount_out" , self . min_amount_out ( ) ) ? ; write ! ( f , ", {}: {}" , "tips_ckb" , self . tips_ckb ( ) ) ? ; write ! ( f , ", {}: {}" , "tips_sudt" , self . tips_sudt ( ) ) ? ; write ! ( f , " }}" ) } } impl < 'r > SwapRequestLockArgsReader < 'r > { pub const TOTAL_SIZE : usize = 105 ; pub const FIELD_SIZES : [ usize ; 6 ] = [ 32 , 32 , 1 , 16 , 8 , 16 , ] ; pub const FIELD_COUNT : usize = 6 ; pub fn sudt_type_hash ( & self ) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked ( & self . as_slice ( ) [ 0 .. 32 ] ) } pub fn user_lock_hash ( & self ) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked ( & self . as_slice ( ) [ 32 .. 64 ] ) } pub fn version ( & self ) -> Uint8Reader < 'r > { Uint8Reader :: new_unchecked ( & self . as_slice ( ) [ 64 .. 65 ] ) } pub fn min_amount_out ( & self ) -> Uint128Reader < 'r > { Uint128Reader :: new_unchecked ( & self . as_slice ( ) [ 65 .. 81 ] ) } pub fn tips_ckb ( & self ) -> Uint64Reader < 'r > { Uint64Reader :: new_unchecked ( & self . as_slice ( ) [ 81 .. 89 ] ) } pub fn tips_sudt ( & self ) -> Uint128Reader < 'r > { Uint128Reader :: new_unchecked ( & self . as_slice ( ) [ 89 .. 105 ] ) } } impl < 'r > molecule :: prelude :: Reader < 'r > for SwapRequestLockArgsReader < 'r > { type Entity = SwapRequestLockArgs ; const NAME : & 'static str = "SwapRequestLockArgsReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { SwapRequestLockArgsReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , _compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len != Self :: TOTAL_SIZE { return ve ! ( Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len ) ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct SwapRequestLockArgsBuilder { pub ( crate ) sudt_type_hash : Byte32 , pub ( crate ) user_lock_hash : Byte32 , pub ( crate ) version : Uint8 , pub ( crate ) min_amount_out : Uint128 , pub ( crate ) tips_ckb : Uint64 , pub ( crate ) tips_sudt : Uint128 , } impl SwapRequestLockArgsBuilder { pub const TOTAL_SIZE : usize = 105 ; pub const FIELD_SIZES : [ usize ; 6 ] = [ 32 , 32 , 1 , 16 , 8 , 16 , ] ; pub const FIELD_COUNT : usize = 6 ; pub fn sudt_type_hash ( mut self , v : Byte32 ) -> Self { self . sudt_type_hash = v ; self } pub fn user_lock_hash ( mut self , v : Byte32 ) -> Self { self . user_lock_hash = v ; self } pub fn version ( mut self , v : Uint8 ) -> Self { self . version = v ; self } pub fn min_amount_out ( mut self , v : Uint128 ) -> Self { self . min_amount_out = v ; self } pub fn tips_ckb ( mut self , v : Uint64 ) -> Self { self . tips_ckb = v ; self } pub fn tips_sudt ( mut self , v : Uint128 ) -> Self { self . tips_sudt = v ; self } } impl molecule :: prelude :: Builder for SwapRequestLockArgsBuilder { type Entity = SwapRequestLockArgs ; const NAME : & 'static str = "SwapRequestLockArgsBuilder" ; fn expected_length ( & self ) -> usize { Self :: TOTAL_SIZE } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { writer . write_all ( self . sudt_type_hash . as_slice ( ) ) ? ; writer . write_all ( self . user_lock_hash . as_slice ( ) ) ? ; writer . write_all ( self . version . as_slice ( ) ) ? ; writer . write_all ( self . min_amount_out . as_slice ( ) ) ? ; writer . write_all ( self . tips_ckb . as_slice ( ) ) ? ; writer . write_all ( self . tips_sudt . as_slice ( ) ) ? ; Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; SwapRequestLockArgs :: new_unchecked ( inner . into ( ) ) } }
